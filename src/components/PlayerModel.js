/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useState } from "react";
import { useFrame } from '@react-three/fiber'
import { useGLTF } from "@react-three/drei";
import { state,setCurrentPlayerPosition, setAnimateNextLevel, setExecuting, setAnimateFall, nextMove, startMoves } from "../State";
import {useSnapshot} from "valtio";
import { LEVELS } from "../Levels";

export const  PlayerModel = (props) =>{
  const {code,executing, level,animateNextLevel,animateFall, moveState} = useSnapshot(state);
  const [celebrate, setCelebrate] = useState(false);
  const [initialPos, setInitialPos] = useState(LEVELS[level]["player"]);
  const [dir, setDir] = useState(0);
  const [dirData, setDirDat] = useState(["z","add"]);
  const meshRef = useRef();
  
  const size = 2;
  let jump = 0;
  let move = 0;

  let fall = 0.05;
  const interval = 0.05;
  const [moves, setMoves] = useState([]);
  
  let x = 0;

  useEffect(()=>{
    if(code)
    {
      const temp=[];
      code.forEach((item)=>{
        temp.push(item.type)
      })
      setMoves(temp)
    }
  },[code])

  useEffect(()=>{
    setInitialPos(LEVELS[level]["player"]);
  }, [level])

  useEffect(()=>{
    setTimeout(()=>setCelebrate(true), 250)
    
  }, [animateNextLevel])
  useEffect(()=>{
    if(executing){
      startMoves();
    }
    if(!executing){
      meshRef.current.position.x=initialPos[0];
      meshRef.current.position.y=initialPos[1];
      meshRef.current.position.z=initialPos[2];
      meshRef.current.rotation.y=0;
      setDir(["z","add"])
    }
  },[executing,initialPos])

  const getDirection = (dir) => {
    console.log("Modulo: ",dir%4)
    if(dir%4===0) setDirDat(["z","add"]);
    else if(dir%4===1 || dir%4 ===-3) setDirDat(["x","sub"]);
    else if(dir%4===-1 || dir%4===3) setDirDat(["x","add"]);
    else if(dir%4===2 || Math.abs(dir)%4===2 ) setDirDat(["z","sub"]);
  }

  useFrame((state, delta, xrFrame) => {
    if(celebrate){
      if (meshRef.current && jump<size) {
        size - jump>= interval? jump +=interval: jump += (size - jump)
        let move = (Math.sin(((jump/size) * Math.PI))) ;
        meshRef.current.rotation.y+= (2*Math.PI) / (size/interval);
       meshRef.current.position.y = initialPos[1] + move
      }
      else{
        setTimeout(()=>{
          setAnimateNextLevel(false);
          setCelebrate(false)
        },250)
      }
    }

    if(animateFall){
      meshRef.current.position.y-=fall*fall;
      fall+=0.05;
      if(meshRef.current.position.y<=-50){
        setAnimateFall(false);
        setExecuting(false);
      }
    }

    if(!animateNextLevel &&!animateFall && moves && moves.length>0 && executing){
      switch (moves[moveState]){
        case "RightCode":
        case "Right":
          if (meshRef.current && jump<size) {
            size - jump>= interval? jump +=interval: jump += (size - jump)
            let move = (Math.sin(((jump/size) * Math.PI))) ;
            meshRef.current.rotation.y-= (Math.PI/2) / (size/interval);
            meshRef.current.position.y = initialPos[1] + move
          }
          else{
            setDir(dir+1);
            nextMove();
            jump =0
            getDirection(dir);
            console.log("Direction: ",dir)
            console.log("Axis: ",dirData[0])
          }
          break;
        case "LeftCode":
        case "Left":
          if (meshRef.current && jump<size) {
            size - jump>= interval? jump +=interval: jump += (size - jump)
            let move = (Math.sin(((jump/size) * Math.PI))) ;
            meshRef.current.rotation.y+= (Math.PI/2) / (size/interval);
            meshRef.current.position.y = initialPos[1] + move
          }
          else{
            setDir(dir-1)
            nextMove()
            jump =0
            getDirection(dir);
            console.log("Direction: ",dir)
            console.log("Axis: ",dirData[0])
          }
          break;
        case "ForwardCode":
        case "Forward":
          if (meshRef.current && move<size) {
            console.log("Axis Confirm: ",dirData[0])
            if(dirData[1] === "add"){
              if(size - move >= interval){
                move +=interval;
                meshRef.current.position[dirData[0]] +=interval;
              }
              else{
                move += (size - move)
                // meshRef.current.position[dirData[0]] -=move-interval            
                // meshRef.current.position[dirData[0]] +=size
                meshRef.current.position[dirData[0]]=Math.ceil(meshRef.current.position[dirData[0]]);
              }
              
              let sinMove = (Math.sin(((move/size) * Math.PI))) ;
              meshRef.current.position.y = 1.5 + sinMove
            }
            else if(dirData[1] === "sub"){
              if(size - move >= interval){
                move +=interval;
                meshRef.current.position[dirData[0]] -=interval;
              }
              else{
                move += (size - move)
                // meshRef.current.position[dirData[0]] +=move-interval  
                // meshRef.current.position[dirData[0]] -= size
                meshRef.current.position[dirData[0]]=Math.floor(meshRef.current.position[dirData[0]]);
              }
              
              let sinMove = (Math.sin(((move/size) * Math.PI))) ;
              meshRef.current.position.y = 1.5 + sinMove
            }
          }
          else{
            move = 0;
            setCurrentPlayerPosition([meshRef.current.position.x,meshRef.current.position.z]);
            nextMove()
          }
          break
        default:
          break
      }
    }

  })
  const { nodes, materials } = useGLTF("/assets/gltf/character_duck.gltf");
  return (
    <group {...props} ref={meshRef} scale={[1.2,1.2, 1.2]} dispose={null}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.character_duck.geometry}
      >
        <meshBasicMaterial color={'#ffffff'}/>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.character_duckArmLeft.geometry}
          position={[0.2, 0.63, 0]}
        />
        <meshBasicMaterial color={'#ffffff'}/>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.character_duckArmRight.geometry}
          position={[-0.2, 0.63, 0]}
        >
          <meshBasicMaterial color={'#ffffff'}/>
        </mesh>
        <group position={[0, 0.7, 0]}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube1338.geometry}
          >
            <meshBasicMaterial color={'#ffffff'}/>
          </mesh>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube1338_1.geometry}
            material={materials.Yellow}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube1338_2.geometry}
            material={materials.Black}
          />
        </group>
      </mesh>
    </group>
  );
}

useGLTF.preload("/assets/gltf/character_duck.gltf");